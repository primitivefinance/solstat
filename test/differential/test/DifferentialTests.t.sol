pragma solidity 0.8.13;

import "forge-std/Test.sol";

import "../../../contracts/Gaussian.sol";

contract DifferentialTests is Test {
    int256[129] data;
    int256[129] _inputs;
    int256[129] _outputs;

    function setUp() public {}

    function loadOutputs() public {
        string[] memory loadJsDataOutputs = new string[](2);
        loadJsDataOutputs[0] = "cat";
        loadJsDataOutputs[1] = "test/differential/data/output";
        bytes memory result = vm.ffi(loadJsDataOutputs);
        _outputs = abi.decode(result, (int256[129]));
    }

    function loadInputs() public {
        string[] memory loadJsDataInputs = new string[](2);
        loadJsDataInputs[0] = "cat";
        loadJsDataInputs[1] = "test/differential/data/input";
        bytes memory loadResult = vm.ffi(loadJsDataInputs);
        _inputs = abi.decode(loadResult, (int256[129]));
    }

    function testSolERFCMatchesTsERFc() public {
        // Run the reference implementation in javascript
        string[] memory runJsInputs = new string[](6);
        runJsInputs[0] = "npm";
        runJsInputs[1] = "--prefix";
        runJsInputs[2] = "differential/scripts/";
        runJsInputs[3] = "--silent";
        runJsInputs[4] = "run";
        runJsInputs[5] = "generate-erfc"; // Generates length 129 by default
        loadOutputs();
        loadInputs();
        //bytes memory jsResult = vm.ffi(runJsInputs);
        //console.logBytes(jsResult);
        //int256[129] memory tsERFCOutputs = abi.decode(jsResult, (int256[129]));

        // Read in the file generated by the reference implementation

        //string[] memory loadJsDataInputs = new string[](2);
        //loadJsDataInputs[0] = "cat";
        //loadJsDataInputs[1] = "differential_testing/data/input";
        //bytes memory loadResult = vm.ffi(loadJsDataInputs);
        //data = abi.decode(loadResult, (int256[129]));

        _testERFC();
    }

    function _getData() public view returns (int256[] memory) {
        int256[] memory _data = new int256[](data.length);
        uint256 length = (data.length);
        for (uint256 i = 0; i < length; ++i) {
            _data[i] = data[i];
        }
        return _data;
    }

    int256 internal constant epsilon = 1e3;

    function _testERFC() public {
        uint256 length = _inputs.length;
        for (uint256 i = 0; i < length; ++i) {
            int256 input = _inputs[i];
            int256 output = _outputs[i];
            int256 computed = Gaussian.erfc(input);
            assertEq(computed / epsilon, output / epsilon);
        }
    }
}
